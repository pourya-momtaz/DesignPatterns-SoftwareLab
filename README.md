# DesignPatterns-SoftwareLab
DesignPatterna-SoftwareLab
<div style="text-align: right"> 
  
  <b> Abstract Factory </b>
  <br>
ابتدا پروژه ساده‌ای با maven ساختم که ساختار فایل pom در تصویر زیر قابل مشاهده است و به سراغ پیاده سازی abstract factory رفته‌ام. این الگو یک الگوی creational است که یک رابط برای ایجاد خانواده‌های اشیاء مرتبط بدون مشخص کردن کلاس‌های مشخص آنها فراهم می‌کند. در این الگو یک رابط کارخانه انتزاعی تعریف می‌کنیم که روش‌هایی را برای ایجاد انواع مختلف اشیاء اعلام می‌کند و سپس کلاس‌های کارخانه‌ای مشخصی ایجاد می‌کند که رابط را پیاده‌سازی کرده و اشیاء خاص را ایجاد می‌کند.
سپس اول تست‌های مربوطه را نوشتم که در تصویر زیر مشاهده می‌کنید.
<br>
  سپس کلاس‌هایی که در تصاویر زیر می‌بینید را پیاده کردم و در نهایت تست را ران کرده‌ام. از آوردن عکس تک تک مراحل تست خودداری کرده‌ام و مراحل مانند آزمایش‌های گذشته انجام شده‎‌اند. در این پروژه یک سازندۀ باغ داریم که دو نوع باغ ژاپنی و ایرانی را تولید می‌کند و دو نوع درخت و گل ایرانی و ژاپنی هم داریم که بسته به نوع سازندۀ باغ، از یکی از آنها استفاده می‌شود. خود سازندۀ باغ، درخت و گل، کلاس‌های abstract هستند اما فرزندان آنها، concrete هستند و هر کدام، پدر را implement کرده‌اند.
  <br>
  
   <b> Prototype </b>
  <br>
در بخش بعد، prototype را پیاده کرده‌ام که یک الگوی طراحی creational است که امکان شبیه سازی یا کپی کردن اشیاء را فراهم می کند. ایده این است که یک شی نمونه اولیه ایجاد کنیم و سپس با شبیه سازی نمونه اولیه، اشیاء جدید ایجاد کنیم. این الگو، زمانی مفید است که ایجاد اشیاء هزینه بر است یا می‌خواهیم اشیاء جدیدی ایجاد کنیم که مشابه اشیاء موجود هستند. در تصاویر زیر، ابتدا تست را مشاهده می‌کنید و سپس پیاده سازی کلاس‌ها و در نهایت نتیجه تست را می‌توانید ببینید. ابتدا رابط Prototype را تعریف کردم که دو روش دارد: getDescription() و clone(). متدgetDescription ()  شرحی از نمونه اولیه را برمی‌گرداند و متد ()clone یک شی جدید ایجاد می‌کند که یک کپی از نمونه اولیه است. سپس دو نمونه اولیه concrete تعریف کردم: ConcretePrototype1 و ConcretePrototype2. هر یک از این کلاس‌ها رابط Prototype را پیاده‌سازی می‌کنند و دارای یک فیلد توضیحات هستند که توصیفی از نمونه اولیه را ذخیره می‌کند. متد ()clone در هر کلاس از متد ()super.clone برای ایجاد یک شی جدید که کپی از نمونه اولیه است استفاده می کند.
 
<br>
     <b> Builder </b>
  <br>
  در بخش بعد، builder را پیاده کرده‌ام که یک الگوی طراحی creational است که از یک شی builder برای ساختن گام به گام شی استفاده کنیم که امکان کنترل بیشتر بر فرآیند ساخت و توانایی ایجاد نمایش های مختلف از یک شی را فراهم می کند. در تصاویر زیر، ابتدا کلاس تست و سپس کلاس‌های دیگر و در نهایت نتیجه تست را می‌توانید مشاهده کنید. ابتدا کلاس Product را تعریف کردم که دارای یک فیلد توضیحات است که توضیحات محصول را ذخیره می کند. کلاس Product همچنین یک متد getDescription()  دارد که توضیحات را برمی گرداند. بعد، رابط Builder را تعریف کردم که دارای سه روش buildPartA()، buildPartB() و buildPartC().  از این روش ها برای ساخت قسمت های مختلف محصول استفاده می شود. رابط Builder همچنین دارای یک متد getResult()  است که محصول نهایی را برمی گرداند. سپس دو سازنده concrete تعریف کردم به نام‌های ConcreteBuilder1 و ConcreteBuilder2.  هر یک از این کلاس ها رابط Builder را پیاده سازی می کنند و یک فیلد محصول دارند که محصول در حال ساخت را ذخیره می کند. متدهای buildPartA()، buildPartB() و buildPartC() در هر کلاس، قسمت های مربوطه را به توضیحات محصول اضافه می کنند. متد getResult()  محصول نهایی را برمی گرداند. در نهایت، کلاس Director را تعریف کردم که دارای یک متد construct()  است که یک شی Builder را می گیرد و از آن برای ساختن محصول گام به گام استفاده می کند.
  <br>
</div>
